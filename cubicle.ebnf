# We simplify the language by not caring about uppercase/lowercase names
# Keywords rules must be placed first everytime to not be matched as names

model =
	[size_proc:size_proc]
	types:type_def_list
	decls:declaration_list
	init:init
	invariants:invariant_list
	unsafes:unsafe_list
	transitions:transition_list
	$
	;

# size procs
size_proc = 'number_procs' ~ @:int ;

# types
type_def_list = {type_def} ; 
type_def = 'type' ~ name:name ['=' ['|'] enum:type_enum] ;
type_enum = @+:name {'|' ~ @+:name} ;

# declarations
declaration_list = {decl} ;
decl = kind:('const' | 'var' | 'array') ~ [template:template_args] name:ref ':' typename:name ;

# init
init = 'init' ~ '(' procs:name_space_list ')' ~ '{' expr:or_expr '}' ;

# invariants
invariant_list = {invariant} ;
invariant = 'invariant' ~ [template:template_args] '(' procs:name_space_list ')' ~ '{' expr:or_expr '}' ;

# unsafe
unsafe_list = {unsafe}+ ;
unsafe = 'unsafe' ~ [template:template_args] '(' procs:name_space_list ')' ~ '{' expr:or_expr '}' ;

# transition
transition_list = {transition} ;
transition =
	'transition' ~ [template:template_args] name:template_name '(' procs:name_space_list ')' ~
	[require:transition_require]
	updates:transition_body
	;
transition_require = 'requires' ~ '{' @:or_expr '}' ;
transition_body = '{' ~ {@+:transition_assign ';'} [@+:transition_assign [';']] '}' ;
transition_assign = lhs:ref ':=' ~ rhs:transition_rvalue ;
transition_rvalue = switch:switch_case | expr:expr | rand:('.' | '?') ;
switch_case = 'case' ~ {@+:case}+ ;
case = '|' ~ cond:('_' | and_expr) ':' ~ expr:expr ;

# expressions

or_expr = @+:and_expr {'||' ~ @+:and_expr} ;
and_expr = @+:bool_expr {'&&' ~ @+:bool_expr} ;
bool_expr = forall:forall_expr | comp:comp_expr ;
forall_expr = 'forall_other' ~ proc:name '.' (comp:comp_expr | '(' expr:or_expr ')') ;
comp_expr = lhs:expr op:('=' | '<>' | '<=' | '<') ~ rhs:expr ;
expr = lhs:rvalue op:('+' | '-') ~ rhs:rvalue | val:rvalue ;
rvalue = ref:ref | const:const ;
const = int | bool ;

ref = array:array_ref | var:var_ref ;
array_ref = name:template_name '[' ~ index:array_index ']' ;
array_index = @+:template_name {',' ~ @+:template_name} ;
var_ref = name:template_name ;

# template
template_args = '@' ~ @+:template {',' ~ @+:template} '@' ; # add condition ?
template_name = @+:/\w*/ {/@/ ~ @+:template '@' ~ @+:/\w*/}* ; # explicit regexp to avoid whitespace in names
template = arg:name | field_ref:template_field_ref | key_ref:int ;
template_field_ref = key:int '.' ~ field:name ;

# lexical elements
name_space_list = {name} ;
name = /[A-Za-z][A-Za-z0-9_]*/ ;
int = /[0-9]+/ ;
bool = 'True' | 'False' ;

