# We simplify the language by not caring about uppercase/lowercase names
#
# Template elements :
# * <str> -> iter on top-level elements of data
# * <int n> -> n-th template argument in the stack
# * <int n>.<str> -> str field of n-th argument in the stack
#
# These elements can be used in:
# * template declaration: comma separated list of elements between two '@' (must point to iterable)
# * template substitution: one element between two '@' in a name
#
# In expressions, supports template constructs:
# @<template decl>@ (&& <and of boolean expressions>)
# @<template decl>@ (|| <or of boolean expressions>)
# 
# In type declaration :
# @<template decl>@ (| <enum names>)
#
# In transition body :
# @<template decl>@ (; <transition updates>)
# @<template decl>@ (| <switch case patterns>)
#
# All statements (but init) can use templates:
# <statement name> @<template_decl>@ <statement stuff>

model =
	[size_proc:size_proc]
	types:type_def_list
	decls:declaration_list
	init:init
	invariants:invariant_list
	unsafes:unsafe_list
	transitions:transition_list
	$
	;

# size procs
size_proc = 'number_procs' ~ @:int ;

# types
type_def_list = {type_def} ; 
type_def = 'type' ~ name:name ['=' ['|'] enum:type_enum_list] ;
type_enum_list = @+:type_enum {'|' ~ @+:type_enum} ;
type_enum = template:enum_template | name:template_name ;
enum_template = template:template_args '(' '|' ~ enum:type_enum_list ')' ;

# declarations
declaration_list = {decl} ;
decl = kind:('const' | 'var' | 'array') ~ [template:template_args] name:ref ':' typename:name ;

# init
init = 'init' ~ '(' procs:name_space_list ')' ~ '{' expr:or_expr '}' ;

# invariants
invariant_list = {invariant} ;
invariant = 'invariant' ~ [template:template_args] '(' procs:name_space_list ')' ~ '{' expr:or_expr '}' ;

# unsafe
unsafe_list = {unsafe}+ ;
unsafe = 'unsafe' ~ [template:template_args] '(' procs:name_space_list ')' ~ '{' expr:or_expr '}' ;

# transition
transition_list = {transition} ;
transition =
	'transition' ~ [template:template_args] name:template_name '(' procs:name_space_list ')' ~
	[require:transition_require]
	'{' ~ updates:transition_update_list '}'
	;
transition_require = 'requires' ~ '{' @:or_expr '}' ;
transition_update_list = {@+:transition_update ';'} [@+:transition_update [';']] ;
transition_update = template:update_template | assign:transition_assign ;
update_template = template:template_args '(' ';' ~ updates:transition_update_list ')' ;

transition_assign = lhs:ref ':=' ~ rhs:transition_rvalue ;
transition_rvalue = switch:switch_case | expr:expr | rand:('.' | '?') ;
switch_case = 'case' ~ @:case_list ;
case_list = {@+:case}+ ;
case_elem = template:case_template | case:case ;
case_template = template:template_args '(' '|' ~ case_list:case_list ')' ;
case = '|' ~ cond:('_' | and_expr) ':' ~ expr:expr ;

# expressions

or_expr = @+:or_elem {'||' ~ @+:or_elem} ;
or_elem = template:or_template | expr:and_expr ;
or_template = template:template_args '(' '||' ~ expr:and_expr ')' ;

and_expr = @+:and_elem {'&&' ~ @+:and_elem} ;
and_elem = template:and_template | expr:bool_expr ;
and_template = template:template_args '(' '&&' ~ expr:and_expr ')' ;

bool_expr = forall:forall_expr | comp:comp_expr ;
forall_expr = 'forall_other' ~ proc:name '.' (comp:comp_expr | '(' expr:or_expr ')') ;
comp_expr = lhs:expr op:('=' | '<>' | '<=' | '<') ~ rhs:expr ;
expr = lhs:rvalue op:('+' | '-') ~ rhs:rvalue | val:rvalue ;
rvalue = const:const | ref:ref ;
const = int | bool ;

ref = array:array_ref | var:var_ref ;
array_ref = name:template_name '[' ~ index:array_index ']' ;
array_index = @+:template_name {',' ~ @+:template_name} ;
var_ref = name:template_name ;

# template
template_args = '@' @+:template {',' ~ @+:template} ['|' ~ cond:or_expr] '@' ;
template_name = @+:/\w*/ {/@/ ~ @+:template '@' ~ @+:/\w*/}* ; # explicit regexp to avoid whitespace in names
template = arg:name | field_ref:template_field_ref | key_ref:int ;
template_field_ref = key:int '.' ~ field:name ;

# lexical elements
name_space_list = {name} ;
name = /[A-Za-z][A-Za-z0-9_]*/ ;
int = /[0-9]+/ ;
bool = 'True' | 'False' ;

