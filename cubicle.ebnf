# We simplify the language by not caring about uppercase/lowercase names
# Keywords rules must be placed first everytime to not be matched as names

model =
	[size_proc:size_proc]
	types:type_def_list
	decls:declaration_list
	init:init
	invariants:invariant_list
	unsafes:unsafe_list
	transitions:transition_list
	$
	;

# size procs
size_proc = 'number_procs' ~ @:int ;

# types
type_def_list = {type_def} ; 
type_def = 'type' ~ name:name ['=' ['|'] enum:type_enum] ;
type_enum = @+:name {'|' @+:name} ;

# declarations (TODO templatize names)
declaration_list = {decl} ;
decl = kind:('const' | 'var' | 'array') ~ name:ref ':' typename:name ;

# init
init = 'init' ~ '(' procs:name_space_list ')' '{' expr:or_expr '}' ;

# invariants
invariant_list = {invariant} ;
invariant = 'invariant' ~ '(' procs:name_space_list ')' '{' expr:or_expr '}' ;

# unsafe (TODO templatize ?)
unsafe_list = {unsafe}+ ;
unsafe = 'unsafe' ~ '(' procs:name_space_list ')' '{' expr:or_expr '}' ;

# transition (TODO templatize)
transition_list = {transition} ;
transition =
	'transition' ~ name:template_name '(' procs:name_space_list ')'
	[require:transition_require]
	updates:transition_body
	;
transition_require = 'requires' ~ '{' @:or_expr '}' ;
transition_body = '{' ~ {@+:transition_assign ';'} [@+:transition_assign [';']] '}' ;
transition_assign = lhs:ref ':=' rhs:transition_rvalue ;
transition_rvalue = switch:switch_case | expr:expr | rand:('.' | '?') ;
switch_case = 'case' ~ {@+:case}+ ;
case = '|' ~ cond:('_' | and_expr) ':' expr:expr ;

# expressions (f_ versions permits forall_other) (TODO templatized ops like &&<T>)

or_expr = @+:and_expr {'||' @+:and_expr} ;
and_expr = @+:bool_expr {'&&' @+:bool_expr} ;
bool_expr = forall:forall_expr | comp:comp_expr ;
forall_expr = 'forall_other' ~ proc:name '.' (comp:comp_expr | '(' expr:or_expr ')') ;
comp_expr = lhs:expr op:('=' | '<>' | '<=' | '<') rhs:expr ;
expr = lhs:rvalue op:('+' | '-') rhs:rvalue | val:rvalue ;
rvalue = ref:ref | const:const ;
const = int | bool ;

ref = array:array_ref | var:var_ref ;
array_ref = name:name '[' ~ index:name_comma_list ']' ;
var_ref = name:name ;

# basic combinations
name_space_list = {name} ;
name_comma_list = @+:name {',' @+:name} ;

# template
template_name = name ;

# lexical elements
name = /\w+/ ;
int = /\d+/ ;
bool = 'True' | 'False' ;

